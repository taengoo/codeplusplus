
SECTION 1: FLYING BEFORE YOU WALK
1.1  INTRODUCTION
1.2  BUILDING A COMPLETE GAME IN 500 LINES
1.3  ADDING THE BOILERPLATE HTML AND CSS
1.4  GETTING STARTED WITH CANVAS
1.5  CREATING YOUR GAME'S STRUCTURE
1.6  LOADING THE SPRITESHEET
1.7  CREATING THE GAME OBJECT
1.8  ADDING A SCROLLING BACKGROUND
1.9  PUTTING IN A TITLE SCREEN
1.10 ADDING A PROTAGONIST
1.11 SUMMARY

----
INTRODUCTION
----
Games have long been a medium that pushes technology to its limits. This book continues that
proud tradition by taking the core technologies of the web—HTML, CSS, and JavaScript—and
pushing them to the edges of their capabilities and performance. HTML5 as a game medium has
come a long way capability-wise in a short amount of time, and many people believe in-browser
gaming will be one of the primary distribution mechanisms for games in the coming years.

Even though it’s not an environment originally designed for creating games, HTML5 is actually
a nice, high-level environment for doing just that. So, in lieu of trying to abstract away all the
boilerplate by building an engine immediately, you can get right to the good stuff: a one-off game
built from the ground up on HTML5—a top-down 2-D space shooter called Alien Invasion.

----
BUILDING A COMPLETE GAME IN 500 LINES
----
To drive home the point of how easy it is to build games in HTML5, the final game you build in the
first three chapters contains fewer than 500 lines of code, all without using any libraries.

----
Understanding the Game
----
Alien Invasion is a top-down 2-D shooter game built in the spirit of the game 1942 (but in space) or
a simplified version of Galaga. The player controls a ship, shown at the bottom of the screen, flying
the ship vertically through an endless space field while defending Earth against an incoming hoard
of aliens.

When played on a mobile device, control is via left and right arrows shown on the bottom left of the
screen, and a Fire button on the right. When played on the desktop, the user can use the keyboard’s
arrow keys to fly and the spacebar to fire.

To compensate for all the different screen sizes of mobile devices, the game resizes the play area to
always play at the size of the device. On the desktop it plays in a rectangular area in the middle of
the browser page.

----
Structuring the Game
----
Nearly every game of this type consists of a few of the same pieces: some asset loading, a title
screen, sprites, user input, collision detection, and a game loop to tie it all together.

The game uses as few formal structures as possible. Instead of building explicit classes, you take
advantage of JavaScript’s dynamic typing (more on this in the section “Building Object-Oriented
JavaScript”). Languages such as C, C++, and Java are called “strongly typed” because you need to
be very explicit about the type of parameters that you pass around to method. This means you need
to explicitly define base classes and interfaces when you want to pass different types of objects to
the same method. JavaScript is weakly (or dynamically) typed because the language doesn’t enforce
the types of parameters. This means you define your objects more loosely, adding methods to each
object as needed, without building a bunch of base classes or interfaces.

Image asset handling is dead simple. You load a single image, called a sprite sheet, that contains all
your game’s sprite images in a single PNG and execute a callback after that image loads. The game
also has a single method for drawing a sprite onto your canvas.

The title screen renders a sprite for the main title and shows the same animated starfield from the
main game moving in the background.

The game loop is also simple. You have an object that you can treat as the current scene, and you
can tell that scene to update itself and then to draw itself. This is a simple abstraction that works for
both title and end game screens as well as the main part of the game.

User input can use a few event listeners for keyboard input and a few “zones” on your canvas to detect
touch input. You can use the HTML standard method addEventListener to support both of these.

Lastly, for collision detection, you punt the hard stuff and just loop over the bounding boxes of each
of the objects to detect a collision. This is a slow and naive way to implement collision detection,
but it’s simple to implement and works reasonably well as long as the number of sprites you check
against is small.

----
The Final Game
----
To get a sense of where the game is headed, check out Figure 1-1,
and visit http://cykod.github.com/AlienInvasion/ on both
a desktop browser and whatever mobile device you have handy.
The game should run on any smartphone that supports HTML5
canvas; however, canvas performance on Android versions
before Ice Cream Sandwich is poor.

Now, it’s time to get started.

----
ADDING THE BOILERPLATE HTML AND CSS
----
The main boilerplate for an HTML5 file is minimal. You
get a valid HTML file with a <canvas> element inside of a
container centered on the page, as shown in Listing 1-1.

LISTING 1-1: Boilerplate game HTML
<!DOCTYPE HTML>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<title>Alien Invasion</title>
<link rel="stylesheet" href="base.css" type="text/css" />
</head>
<body>
<div id='container'>
<canvas id='game' width='320' height='480'></canvas>
</div>
<script src='game.js'></script>
</body>
</html>

The only external files so far are the base.css file, an external style sheet, and a nonexistent
game.js file that will contain the JavaScript code for the game. Drop the HTML from Listing 1-1
into a new directory, and call it index.html.

In base.css you need two separate sections. The first is a CSS reset. CSS resets make sure all elements
look the same in all browsers and any per-element styling and padding is removed. To do this,
the reset sets the size of all elements to 100% (16 pixels for fonts) and removes all padding, borders,
and margins. The reset used is the well-known Eric Meyer reset: http://meyerweb.com/eric/
tools/css/reset/.

You can simply copy the CSS code verbatim to the top of base.css.

Next, you need to add two additional styles to the CSS file, as shown in Listing 1-2.

LISTING 1-2: Base canvas and container styles
/* Center the container */
#container {
padding-top:50px;
margin:0 auto;
width:480px;
}
/* Give canvas a background */
canvas {
background-color: black;
}

The first container style gives the container a little padding at the top of the page and centers its content
in the middle of the page. The second style gives the canvas element a black background.

---
GETTING STARTED WITH CANVAS
----
You hopefully noticed a canvas tag in the middle of the HTML on the page (as shown in
Listing 1-2):

<canvas id='game' width='320' height='480'></canvas>

This is where all the action for the game takes place—so much exciting stuff you can do in such an
unassuming tag.

The tag has an id for easy reference along with a width and height. Unlike most HTML elements,
you generally never want to add a CSS width and height onto canvas elements. Those styles visually
resize your canvas but do not affect the pixel dimensions of the canvas, which is controlled by
the width and height on the element. Most of the time you should leave these alone.

----
Accessing the Context
----
Before you can do any drawing onto canvas, you need to fetch the context from the canvas element.
The context is the object that you actually make API calls against (not the canvas element itself.)
For 2-D canvas games, you can pull out the 2-D context, as shown in Listing 1-3.

LISTING 1-3: Accessing the rendering context
var canvas = document.getElementById('game');

var ctx = canvas.getContext && canvas.getContext('2d');
if(!ctx) {
// No 2d context available, let the user know
alert('Please upgrade your browser');
} else {
startGame();
}
function startGame() {
// Let's get to work
}

First, grab the element from the document. These initial chapters use built-in browser methods for
all DOM (Document Object Model) interaction; later you are introduced to how to do the same
things more concisely using jQuery.

Next, call getContext on the canvas element. A double-ampersand (&&) short circuit operator protects
you from calling a nonexistent method. This is used in the next if statement in case the visiting
browser doesn’t support the canvas element. You always want to “fail loudly” in this case, so
the players correctly blame their browser instead of your code. “Failing loudly” means that instead
of “failing silently” with a white screen and an error hiding on the JavaScript console, the game
explicitly pops up with a message that tells the user that something went wrong.

There is a 3-D WebGL-powered rendering context available on desktop browsers (excluding
Internet Explorer), but it is called glcanval and is available only on mobile Nokia devices at the
time of this writing. WebGL is another standard, separate from HTML5, that allows you to use
hardware-accelerated 3-D graphics in the browser.

Add the code from Listing 1-3 to a file named game.js. You now can start playing with the canvas
element.

----
Drawing on Canvas
----
This initial tutorial doesn’t use any of the vector-based drawing routines, but for the sake of getting
something up on the screen quickly, you can draw a rectangle on the page. Modify the startGame()
method of your game.js file to read as follows:

function startGame() {
ctx.fillStyle = "#FFFF00";
ctx.fillRect(50,100,380,400);
}

To draw a filled rectangle, you use the fillRect method on the ctx object, but first you need to set
a fill style. You can pass in standard CSS color representations as strings to fillStyle, including
hexadecimal colors, RGB triples, or RGBA quads.

To layer a semitransparent rectangle on top of the existing one, add the following:

function startGame() {
ctx.fillStyle = "#FFFF00";
ctx.fillRect(50,100,380,400);
// Second, semi-transparent blue rectangle
ctx.fillStyle = "rgba(0,0,128,0.5);";
ctx.fillRect(0,50,380,400);
}

If you add the preceding code and reload your index.html file, you see a nice, big blue rectangle
smack dab in the middle of your black canvas.

----
Drawing Images
----
Alien Invasion is an old-school, top-down 2-D shooter game with retro-looking bitmap graphics.
Luckily canvas provides an easy method called drawImage that comes in a couple of flavors, depending
upon whether you want to draw an entire image or just a portion of an image.

The only complication is that, to draw those graphics, the game needs to load the image first. This
isn’t a huge deal because browsers are handy at loading images; however, they load them asynchronously,
so you need to wait for a callback to let you know that the image is ready to go.

Make sure you have copied the sprites.png file over from the book assets for Chapter 1 into an
images/ directory underneath your current game, and then add the code from Listing 1-4 to the
bottom of your startGame function.

LISTING 1-4: Drawing images with canvas (canvas/game.js)
function startGame() {
ctx.fillStyle = "#FFFF00";
ctx.fillRect(50,100,380,400);
// Second, semi-transparent blue rectangle
ctx.fillStyle = "rgba(0,0,128,0.8);";
ctx.fillRect(25,50,380,400);
var img = new Image();
img.onload = function() {
ctx.drawImage(img,100,100);
}
img.src = 'images/sprites.png';
}

If you reload the page, you should now see the sprite sheet layered
on top of your rectangles. See canvas/game.js in the chapter
code for the complete code. You can see the code first waits
for the onload callback before trying to draw the image onto the
context and then sets the src after setting up the callback. The
order is important because Internet Explorer does not trigger the
onload callback if the image is cached if you reverse the order of
the two lines. You can see the results—admittedly not pretty—in
Figure 1-2.

This first example uses the simplest drawImage method—one
that takes an image and an x and y coordinate and then draws
the entire image on the canvas.

Modify the drawImage line to read as follows:

var img = new Image();
img.onload = function() {
ctx.drawImage(img,100,100,200,200);
}
img.src = 'images/sprites.png';

The image has now shrunk down to the size of the extra parameters that you passed in which are
the destination width and height. This is a second form of drawImage that enables you to scale
images up or down to any dimensions.

The last form of drawImage, however, is the one that you'll use the most often with bitmapped
games. It is also the most complicated and takes a total of nine parameters:

drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)

This form enables you to specify a source rectangle in the image using parameters sx, sy, sWidth,
and sHeight and a destination rectangle on the canvas using parameters dx, dy, dWidth, and
dHeight. As you’ve probably figured out, to pull out an individual frame from one of the sprites
in the sprite sheet, this is the format you want to use. Now give it a shot by changing the call to
drawImage to:

var img = new Image();
img.onload = function() {
ctx.drawImage(img,18,0,18,25,100,100,18,25);
}
img.src = 'images/sprites.png';

If you reload the page, you see there’s now a single instance of the player ship on the canvas. So far
so good. In the next section, you start to build out the structure for an actual game.

IMMEDIATE VERSUS RETAINED MODE
---->
---->
Canvas is a tool for creating games in what’s commonly referred to as Immediate
mode. When you use canvas, all you are doing is drawing pixels onto the page.
Canvas doesn’t know anything about your spaceships or missiles that fly around.
All it cares about are pixels, and most canvas games clear the canvas completely
between frames and redraw everything at an updated position.

Contrast this with using the DOM to create a game. Using the DOM would be
equivalent to creating a game in Retained mode, as the browser keeps track of the
“scene graph” for you. This scene graph keeps track of the position and hierarchy
of objects. Instead of starting from scratch in each frame, you need to adjust only
the elements that have changed and the browser takes care of rendering everything
correctly. Which is better? Well, it depends on your game. See the discussion in
Chapter 12, “Building Games in CSS3,” to learn when to use which method.
---->

----
CREATING YOUR GAME’S STRUCTURE
----
The code built so far has been a good way to exercise the canvas capabilities you’ll be using, but it
will need to be reorganized to turn it into a useful structure for a game. Now take a step back to
look at some of the patterns you want to use putting together the game.

----
Building Object-Oriented JavaScript
----
JavaScript is an object-oriented (OO) language. As such, most elements in JavaScript are objects
including strings, arrays, functions and, well, objects are objects in the OO sense.

But this doesn’t mean that JavaScript has all the trappings of object-oriented programming (OOP)
that you might expect. First, it doesn't have a classical inheritance model. Second, it doesn't have a
standard constructor mechanism, relying instead on either constructor functions or object literals.

Instead of classical inheritance, JavaScript implements prototypical inheritance, meaning you can
create an object that represents the prototype, or blueprint, for a set of descendant objects that all
share the same base functionality.

CLASSICAL VERSUS PROTOTYPICAL INHERITANCE
---->
---->
Most popular object-oriented languages used today, including Java and C++,
rely on classical inheritance, which means object behavior is defined by creating
explicit classes and instantiating objects from those classes. JavaScript has a
much more fluid method of defining classes based on the idea of prototypes, which
means you create an actual object that behaves the way you want and then create
child objects off of that.
---->

Because methods are just regular JavaScript objects, many times developers also simply copy
attributes from other objects to fake Java-style interfaces or multiple inheritance. This flexibility
shouldn’t necessarily be viewed as a problem; rather, it means that developers have a lot of flexibility
for how to create objects and can pick the best method for the specific use case.

Alien Invasion uses constructor functions combined with prototypical inheritance where it makes
sense. Using object prototypes can make object creation up to 50 times faster and provides memory
savings, but it is also more restricting because you can’t use closures to access and protect data.
Closures are a feature of JavaScript that allows you to keep variables in a method around for later
use even when a method has finished execution.

Chapter 9, “Bootstrapping the Quintus Engine: Part I,” discusses object-creation patterns in more
detail, but for now just realize that the use of different methods is intentional.

----
Taking Advantage of Duck Typing
----
There’s a famous saying that if it walks like a duck and talks like a duck, then it must be a duck.
When programming in strongly-typed languages, there’s no doubt whether it’s a duck—it must be
an instance of the “Duck” class, or if you program in Java, implement the iDuck interface.

In JavaScript, a dynamically-typed language, parameters, and references are not type-checked,
meaning you can pass any type of object as a parameter to any function, and that function happily
treats that object like the type of whatever object it was expecting until something blows up.

This flexibility can be both a good and a bad thing. It’s a bad thing when you end up with cryptic
error messages or errors during run time. It’s a good thing when you use that flexibility to keep a
shallow inheritance tree but can still share code. The idea of using objects based on their external
interface rather than their type is called duck typing.

Alien Invasion uses this idea in a couple of places: game screens and sprites. The game treats anything
that responds to method calls of step() and draw() as valid game screen objects or valid sprites.
Using duck typing for game screens enables Alien Invasion to treat title screens and in-game screens
as the same type of object, making it easy to switch between levels and title screens. Similarly, using
duck typing for sprites means that the game can be flexible with what can be added to a game board,
including the player, enemies, projectiles, and HUD elements. HUD, which is short for Heads Up
Display, is the term commonly used for elements that sit on top of the game, such as number of lives
left and the player’s score.

----
Creating the Three Principle Objects
----
The game needs three principle, mostly persistent objects: a Game object tying everything together; a
SpriteSheet object for loading and drawing sprites; and a GameBoard object for displaying, updating,
and handling the collision of sprite elements. The game also needs a gaggle of different sprites
such as the player, enemies, missiles, and HUD objects, such as the score and number of remaining
lives, but those are introduced individually later.

----
LOADING THE SPRITESHEET
----
You have already seen most of the code necessary to load a sprite sheet and display sprites on the page.
All that remains is to extract the functionality into a package. One enhancement puts in a map of
sprite names to their locations to make it easier to draw the sprites on the screen. A second enhancement
encapsulates the onload callback functionality to hide the details from any calling classes.

Listing 1-5 shows the entire class.

LISTING 1-5: The SpriteSheet class
var SpriteSheet = new function() {
this.map = { };
this.load = function(spriteData,callback) {
this.map = spriteData;
this.image = new Image();
this.image.onload = callback;
this.image.src = 'images/sprites.png';
};
this.draw = function(ctx,sprite,x,y,frame) {
var s = this.map[sprite];
if(!frame) frame = 0;
ctx.drawImage(this.image,
s.sx + frame * s.w,
s.sy,
s.w, s.h,
x, y,
s.w, s.h);
};
}

Although the class is short and has only two methods, it does have a number of things to note. First,
because there can be only one SpriteSheet object, the object is created with

new function() { ... }

This puts the constructor function and the new operator on the same line, ensuring that only one
instance of this class is ever created.

Next, two parameters pass into the constructor. The first parameter, spriteData, passes in sprite
data linking the rectangles of sprites to names. The second parameter, callback, passes as a callback
to the image onload method.

The second method, draw, is the main workhorse of the class because it does the actual drawing of
sprites onto a context. It takes as parameters the context, the string specifying the name of a sprite
from the spriteData map, an x and y location to draw the sprite, and an optional frame for sprites
with multiple frames.

The draw method uses those parameters to look up the spriteData in the map to get the source
location of the sprite as well as the width and height. (For this simple SpriteSheet class, every
frame of the sprite is expected to be the same size and on the same line.) It uses that information to
figure out the parameters to the more complicated drawImage method, discussed in the “Drawing
Images” section earlier in this chapter.

Although this code is designed to be a one-off and only useful for this specific game, you still need
to separate the game data, such as the sprite data and levels, from the game engine to make it easier
to test and build in pieces.

Add in the SpriteSheet to the top of a new file called engine.js file and replace the startGame
function in game.js with the following code:

function startGame() {
SpriteSheet.load({
ship: { sx: 0, sy: 0, w: 18, h: 35, frames: 3 }
},function() {
SpriteSheet.draw(ctx,"ship",0,0);
SpriteSheet.draw(ctx,"ship",100,50);
SpriteSheet.draw(ctx,"ship",150,100,1);
});
}

Here the StartGame function calls SpriteSheet.load and passes in the details for a couple of
sprites. Next, in the callback function (after the images/sprites.png file loads) to test out the
drawing function, it draws three sprites on the canvas.

Here the StartGame function calls SpriteSheet.load and passes in the details for a couple of
sprites. Next, in the callback function (after the images/sprites.png file loads) to test out the
drawing function, it draws three sprites on the canvas.

Modify the bottom of your index.html file to load engine.js first and then game.js:

<body>
<div id='container'>
<canvas id='game' width='480' height='600'></canvas>
</div>
<script src='engine.js'></script>
<script src='game.js'></script>
</body>

Check out sprite_sheet/index.html in the chapter code for the preceding example in a
working form.

Now that the game can draw sprites on the page, you can set up the main game object to orchestrate
everything else.

----
CREATING THE GAME OBJECT
----
The main game object is a one-off object called, perhaps not surprisingly, Game. Its main purpose is
to initialize the game engine for Alien Invasion and run the game loop as well as provide a mechanism
for changing the main scene that displays.

Because Alien Invasion doesn’t have an input subsystem, the Game class is also responsible for setting
up listeners for keyboard and touch input. To start, only keyboard input is handled; touch input
is added in the next chapter.

Now that the game starts to take shape, a few additional considerations are necessary. Instead of
just executing code willy-nilly when it is evaluated, it generally makes sense to wait for the page to
finish downloading before initializing the game. The Game class takes this into consideration and
listens for a “load” event from the window before booting up the game.

The code for the Game class will be added at the top of engine.js.

----
Implementing the Game Object
----
Now walk through the 40+ lines of code that make up the Game object a section at a time. (See the
full listing at the top of game_class/engine.js in the chapter code.) The class starts off much like
the SpriteSheet, as a one-time class instance:

var Game = new function() {

Next is the initialization routine, called with the ID of the canvas element to fill, the sprite data that
is passed to the SpriteSheet, and the callback when the game is ready to start.

// Game Initialization
this.initialize = function(canvasElementId,sprite_data,callback) {
this.canvas = document.getElementById(canvasElementId);
this.width = this.canvas.width;
this.height= this.canvas.height;
// Set up the rendering context
this.ctx = this.canvas.getContext && this.canvas.getContext('2d');
if(!this.ctx) { return alert("Please upgrade your browser to play"); }
// Set up input
this.setupInput();
// Start the game loop
this.loop();
// Load the sprite sheet and pass forward the callback.
SpriteSheet.load(sprite_data,callback);
};

Much of this code should be familiar from earlier in the chapter. The parts where you grab the
canvas element and check for a 2d context are straightforward. Next is a call to setupInput(),
which is discussed next. Finally, the game loop starts, and the data for the sprite sheet passes
through to SpriteSheet.load.

The next section sets up input:

// Handle Input
var KEY_CODES = { 37:'left', 39:'right', 32 :'fire' };
this.keys = {};
this.setupInput = function() {
window.addEventListener('keydown',function(e) {
if(KEY_CODES[event.keyCode]) {
Game.keys[KEY_CODES[event.keyCode]] = true;
e.preventDefault();
}
},false);
window.addEventListener('keyup',function(e) {
if(KEY_CODES[event.keyCode]) {
Game.keys[KEY_CODES[event.keyCode]] = false;
e.preventDefault();
}
},false);
}

The main point of this block is to add event listeners for keydown and keyup events for those keys
that you care about: specifically the left arrow, the right arrow, and the spacebar. For those events,
the listeners translate a numeric Keycode to a friendlier identifier and update a hash called Game.keys
to represent the current state of the user input. The player uses the Game.keys hash to control the
ship. For keys used by the game, the event handlers also call e.preventDefault(), which prevents
the browser from performing any default behavior in response to the key presses. (For the arrow keys
and the spacebar, the browser would normally try to scroll the page.)

One more point about the preceding event handler code: It uses the W3C event model
addEventListener method. This code is supported in current versions of the Chrome,
Safari, and Firefox browsers, but only Internet Explorer (IE) versions 9 and above. This is
not a huge deal because canvas isn’t supported pre-IE9 in any case, but if you want to add
compatibility for older browsers, it’s something you need to be careful with. (The engine built
starting in Chapter 9, “Bootstrapping the Quintus Engine Part I,” uses jQuery’s on method to
enable easy browser-independent event attachment.)

The last section of the Game class is relatively short:

// Game Loop
var boards = [];
this.loop = function() {
var dt = 30/1000;
for(var i=0, len = boards.length;i<len;i++) {
if(boards[i]) {
boards[i].step(dt);
boards[i] && boards[i].draw(Game.ctx);
}
}
setTimeout(Game.loop,30);
};
// Change an active game board
this.setBoard = function(num,board) { boards[num] = board; };
};

The boards are the pieces of the game updated and drawn onto the canvas. An example of a board
might be a background or a title screen. (In the next chapter, you create a special board for handling
sprites.) The Game.loop function loops through all the boards, checks if there is a board at
that index, and if so, calls that board’s step method with the approximate number of seconds that
have passed, followed by calling the board’s draw method, passing in the rendering context. For the
draw call, the step call may have removed the board, so checking again that the board exists with
boards[i] && keeps the code from blowing up. Finally, setTimeout is used in the loop function
to ensure that the loop runs again in 30 milliseconds. Using setTimout instead of setInterval
ensures that timer events don’t back up if the game slows down, which could lead to strange warplike
behavior. Because setTimeout doesn’t retain the context of the called function, Game.loop
needs to explicitly refer to the Game object instead of using the this keyword.

TIMER METHODS
---->
---->
There’s more to JavaScript timers for game development than just setTimeout
or setInterval. Chapter 9 discusses the requestAnimationFrame method that
enables the browser to sync calls to your game with screen updates. Also, hard
coding the amount of time that has passed to a fixed number is generally a bad
idea as the timer may be called at different intervals depending on browser performance,
but it should be okay for this simple type of game.
---->

Because boards drop from index 0 to the highest index, background boards (such as the starfield in
the next section) should be added to lower indexes, whereas elements added at the end, such as the
score and HUDs, should be drawn last.

Finally, the only method on the Game object that is called regularly during the game, Game.setBoard, is
defined. All this method does is set one of the game boards used in the loop method. It is used to switch
active GameBoards, which are used for title screens as well as the main section of the game.

----
Refactoring the Game Code
----
As you build games in the browser, you’ll want to keep attention on the structure of what you’re
building. JavaScript is a very flexible language, and without some discipline in how your game is
structured, things can fall apart quickly. A common pattern in this book will be to show you how
to use an API or technique quickly and simply and then take some time to structure that code into a
library or module.

The initial code for displaying a sprite on the screen in game.js is going to be replaced with code
that does the same but is structured in a way to be usable in a more complicated game.

Update game.js to use the Game class. Remove anything you have in game.js and add the code
shown in Listing 1-6.

LISTING 1-6: A refactored game.js method (game_class/game.js)
var sprites = {
ship: { sx: 0, sy: 0, w: 18, h: 35, frames: 3 }
};
var startGame = function() {
SpriteSheet.draw(Game.ctx,"ship",100,100,1);
}
window.addEventListener("load", function() {
Game.initialize("game",sprites,startGame);
});

All this code does is set up the available sprites, create a dummy startGame function that draws a
ship on the canvas to make sure everything is working correctly, and then listen for the load event
on the window object to call the Game.initialize function with the appropriate arguments.

Reload your index.html file (or run the code example game_class/index.html) to see a lonesome
ship hanging out near the canvas element.

----
ADDING A SCROLLING BACKGROUND
----
Are you crying out for something more interesting than boilerplate setup code? Here’s the good
news: From here on it gets much more interesting. Start by adding an animated starfield onto the
page to give the game some space-like qualities.

You can create a scrolling starfield in a few ways, but in this case you need to be a little careful with
the number of objects that get drawn on the screen because drawing too many sprites per frame
slows down the game on mobile devices. One way around this is to create an offscreen canvas buffer,
draw a bunch of random stars on that buffer, and then simply draw that starfield moving slowly
down the canvas. You’ll be limited to a few different layers of moving stars, but this effect should be
good enough for a retro shooter.

THE VAGARIES OF HTML5 PERFORMANCE
---->
---->
The performance question isn’t straightforward. One of the truisms of HTML5 is
that you never know what method has better performance without trying it out.
When deciding which way to implement a feature, your best bet is to go right to
the source: Test it out! You can see the performance for different numbers of stars
and ways to draw starfields at http://jsperf.com/prerendered-starfield.
JSPerf.com is a great place to test your intuition. To see the results of the starfield
test, scroll down the page and hit “Run Tests” to see the performance of the different
runs. In this case, the answer isn't so cut and dry. Most desktops do better
drawing individual stars, whereas iOS mobiles do better drawing the offscreen
buffer, at the time of this writing at least. As canvas will get better hardware
acceleration across the board in the near future, it seems like a safe bet that the
fillrate limited offscreen buffer (as described in this section) will be substantially
faster in the months and years to come.
---->

Now break down a few of the necessary pieces before looking at the class as a whole. (You can skip
to the end of the section to see the full class if you want to peek ahead.)

The StarField class needs to do three main things. The first is to create an offscreen canvas. This
is actually quite easy because canvas is just a regular DOM element with two attributes, width and
height, and can be created the same way as any other DOM elements:

var stars = document.createElement("canvas");
stars.width = Game.width;
stars.height = Game.height;
var starCtx = stars.getContext("2d");

Because the stars field needs to be the same size as the game’s canvas, you can set the size by pulling
out the width and height properties that were set in the Game.initialize method.

After you create the canvas, you can start drawing stars (or rectangles) onto it. The easiest way to
do this is to call fillRect once for each star that needs to be drawn. A for loop combined with
using Math.random() to generate a random x and y location gets the job done:

starCtx.fillStyle = "#FFF";
starCtx.globalAlpha = opacity;
for(var i=0;i<numStars;i++) {
starCtx.fillRect(Math.floor(Math.random()*stars.width),
Math.floor(Math.random()*stars.height),
2,
2);
}

The only piece that hasn’t been mentioned is the globalAlpha property. This property sets the
level of opacity for the canvas element. Because there are multiple layers of stars moving at different
speeds, a nice effect is to have the slower stars be slightly less bright than the faster moving ones to
simulate their being farther away.
Next is the draw method. The Starfield needs to draw the entire canvas element containing the
stars onto the game’s canvas; however, because it will scroll constantly, it needs to be drawn twice:
once for the top half and once for the bottom half. The method uses the starfield’s offset, a number
between zero and the height of the game to first draw whatever part of the starfield has been shifted
off the bottom of the game back at the top, and then draws the bottom part.
this.draw = function(ctx) {
var intOffset = Math.floor(offset);
var remaining = stars.height - intOffset;
if(intOffset > 0) {
ctx.drawImage(stars,
0, remaining,
stars.width, intOffset,
0, 0,
stars.width, intOffset);
}
if(remaining > 0) {
ctx.drawImage(stars,
0, 0,
stars.width, remaining,
0, intOffset,
stars.width, remaining);
}
}

The code looks slightly confusing because it uses the nine-parameter version of drawImage to draw
the slices, but it’s actually just slicing the starfield into a top half and a bottom half, and drawing the
top half at the bottom of the game canvas and the bottom half at the top of the canvas.

Listing 1-7 shows the Starfield class in its entirety, which should go into the game.js file.

LISTING 1-7: The Starfield (starfield/game.js)
var Starfield = function(speed,opacity,numStars,clear) {
// Set up the offscreen canvas
var stars = document.createElement("canvas");
stars.width = Game.width;
stars.height = Game.height;
var starCtx = stars.getContext("2d");
var offset = 0;
// If the clear option is set,
// make the background black instead of transparent
if(clear) {
starCtx.fillStyle = "#000";
starCtx.fillRect(0,0,stars.width,stars.height);
}
// Now draw a bunch of random 2 pixel
// rectangles onto the offscreen canvas
starCtx.fillStyle = "#FFF";
starCtx.globalAlpha = opacity;
for(var i=0;i<numStars;i++) {
starCtx.fillRect(Math.floor(Math.random()*stars.width),
Math.floor(Math.random()*stars.height),
2,
2);
}
// This method is called every frame
// to draw the starfield onto the canvas
this.draw = function(ctx) {
var intOffset = Math.floor(offset);
var remaining = stars.height - intOffset;
// Draw the top half of the starfield
if(intOffset > 0) {
ctx.drawImage(stars,
0, remaining,
stars.width, intOffset,
0, 0,
stars.width, intOffset);
}
// Draw the bottom half of the starfield
if(remaining > 0) {
ctx.drawImage(stars,
0, 0,
stars.width, remaining,
0, intOffset,
stars.width, remaining);
}
}
// This method is called to update
// the starfield
this.step = function(dt) {
offset += dt * speed;
offset = offset % stars.height;
}
}

Only two parts haven’t been discussed. The step function at the bottom gets called with the fraction
of a second that has elapsed since the last call to step. All it needs to do is update the offset
variable based on the elapsed time and the speed, and then use the modulus (%) operator to make
sure the offset is between zero and the height of the Starfield.

There's also a conditional to check if the clear parameter is set. This parameter is used to fill the
first layer of stars with a black fill. (Later layers need to be transparent so that they overlay over each
other correctly.) This prevents the need to explicitly clear the canvas between frames and saves some
processing time.

To see the starfield in action, you need to modify your startGame function in game.js to add some
starfields. Modify it to add three starfields of varying opacity by setting it to the following:

var startGame = function() {
Game.setBoard(0,new Starfield(20,0.4,100,true))
Game.setBoard(1,new Starfield(50,0.6,100))
Game.setBoard(2,new Starfield(100,1.0,50));
}

Only the first starfield has the clear parameter set to true. Each starfield has a higher speed combined
with a higher opacity than the last. This gives an effect of stars at different distances speeding by.

----
PUTTING IN A TITLE SCREEN
----
An animated starfield, although nice, isn't a game. To start to build out the same elements of the
game, one of the first requirements for a game is to display a title screen showing the users what
they can play.

The title screen for Alien Invasion isn't going to be anything special—just a text title and a subtitle.
So a generic GameScreen class with a title and subtitle centered on the screen is enough to get the
job done.

----
Drawing Text on Canvas
----
Drawing text on the canvas is straightforward and allows you to use any font loaded on the page.
This flexibility means you can use any of the standard web-safe fonts as well as any fonts that have
been loaded via @font-face onto the page.

The declarations for @font-face take some care because depending on the browsers that need to be
supported, four different file formats need to be available. Luckily, if you aren't going to install the
files locally, but rather serve them off an online service such as the free Google web fonts, all that's
needed is a single linked style sheet. (You can browse the fonts available for free use at Google web
fonts at (www.google.com/webfonts.)

For Alien Invasion, the font Bangers gives the game a nice retro “Invasion of the Body Snatchers”
feel. Add the following line to your HTML (not your JavaScript) below the base.css link tag:

<head>
<meta charset="UTF-8"/>
<title>Alien Invasion</title>
<link rel="stylesheet" href="base.css" type="text/css" />
<link href='http://fonts.googleapis.com/css?family=Bangers'
rel='stylesheet' type='text/css'>
</head>

Next, the game needs a TitleScreen class to display some text centered on the screen. To do this
you must use a new canvas method that hasn’t been discussed yet, fillText, and two new canvas
properties, font and textAlign.

The current font used is set by passing a CSS style to context.font, for example:

ctx.font = "bold 25px Arial";

This declaration would set the current font used by both measureText and fillText to 25 pixels
high, make it bold, and use the Arial font family.

To make sure the text is centered on a specific location horizontally, you’ll need to set the context
.textAlign property to center.

ctx.textAlign = "center";

After you calculate the location for the text and set the font style appropriately, you can use
fillText to draw solid text onto the canvas:

fillText(string, x, y);

fillText takes the string to draw and an x and y location for the top-left corner.

Armed with these text-drawing methods, you now have the tools to draw a title screen that shows a
title and a subtitle and calls an optional callback when the user presses the fire key.

Listing 1-8 shows the code to get that done. Add the TitleScreen class to the bottom of your
engine.js file.

LISTING 1-8: The TitleScreen (titlescreen/engine.js)
var TitleScreen = function TitleScreen(title,subtitle,callback) {
this.step = function(dt) {
if(Game.keys['fire'] && callback) callback();
};
this.draw = function(ctx) {
ctx.fillStyle = "#FFFFFF";
ctx.textAlign = "center";
ctx.font = "bold 40px bangers";
ctx.fillText(title,Game.width/2,Game.height/2);
ctx.font = "bold 20px bangers";
ctx.fillText(subtitle,Game.width/2,Game.height/2 + 40);
};
};

Similar to the Starfield object, TitleScreen defines a step and a draw method. The step method
has only one task: to check if the fire key is pressed, and if so, call the callback that was passed in.

The draw does the majority of the actual work. First, it sets a fillStyle (white) that will be used
on both the title and subtitle. Next, it sets the font for the title. You can horizontally center the title
on the page by moving x to half the width of the canvas. Next is a call to fillText with this calculated
x location and half the height of the canvas.

To draw the subtitle, the same calculation is repeated with a new font, and then the vertical position
is offset by 40 pixels to place it below the title.

You now need to add the title screen onto the page as a new board above the background starfields.
Modify your startGame method as shown, and add in a new callback called playGame:

var startGame = function() {
Game.setBoard(0,new Starfield(20,0.4,100,true))
Game.setBoard(1,new Starfield(50,0.6,100))
Game.setBoard(2,new Starfield(100,1.0,50));
Game.setBoard(3,new TitleScreen("Alien Invasion",
"Press space to start playing",
playGame));
}

var playGame = function() {
Game.setBoard(3,new TitleScreen("Alien Invasion", "Game Started..."));
}

If you reload the browser, you should see a title screen, and after you press the spacebar, the title
screen should update the subtitle to say “Game Started.” The playGame function will be replaced
with code to actually start to play the game in the next section.

----
Creating the PlayerShip Object
----
The first step is to get a ship created and drawn on the page. Open up game.js and add the player
ship class to the bottom:

var PlayerShip = function() {
this.w = SpriteSheet.map['ship'].w;
this.h = SpriteSheet.map['ship'].h;
this.x = Game.width/2 - this.w / 2;
this.y = Game.height - 10 - this.h;
this.vx = 0;
this.step = function(dt) {
// TODO – added the next section
}
this.draw = function(ctx) {
SpriteSheet.draw(ctx,'ship',this.x,this.y,1);
}
}

Much like a game screen, a sprite has the same two external methods: step and draw. Keeping the
interface consistent allows sprites and game screens to be mostly interchangeable. In initializing
the sprite, a few more variables are set that give the sprite a position on the page and a height and
a width. (The next chapter uses the position and height and width to do simple bounding box collision
detection.)

The width and height of the sprite are pulled from the sprite sheet. Although you could hard-code
the width and height here, using the dimensions from the sprite sheet mean there is only one location
that needs to be changed if the dimensions need to be changed.

Next, modify the playGame function to read as follows:

var playGame = function() {
Game.setBoard(3,new PlayerShip());
}

If you reload the index.html file and press the spacebar, you can see the player ship hanging out at
the bottom of the page.

----
Handling User Input
----
The next task is to accept user input to allow the player to move the ship back and forth across the
game. This is handled in the step function inside of PlayerShip.

The step function has three main parts. The first is to check for user input to update the ship’s movement
direction; the second is to update the x coordinate based on the direction; and finally the function
needs to check that the updated x position is within the bounds of the screen. Replace the TODO
comment in the preceding step method with the following code:

this.step = function(dt) {
this.maxVel = 200;
this.step = function(dt) {
if(Game.keys['left']) { this.vx = -this.maxVel; }
else if(Game.keys['right']) { this.vx = this.maxVel; }
else { this.vx = 0; }
this.x += this.vx * dt;
if(this.x < 0) { this.x = 0; }
else if(this.x > Game.width - this.w) {
this.x = Game.width - this.w;
}
}
}

The first part of the method checks the Game.keys map to see if the user is currently pressing the
left or the right arrow keys, and if so sets the velocity to the correct positive or negative value. The
second part of the code simply updates the x position with the current velocity multiplied by the
fraction of a second since the last update. Finally, the method checks to see if the x position is either
off the left side of the screen (less than zero) or off the right side of the screen (greater than the
width of the screen minus the width of the ship). If either of those conditions is true, the value of x
is modified to be within that range.

----
SUMMARY
----
You now know how to get the framework of an HTML5 game up-and-running, including loading a
sprite sheet, drawing on canvas, adding in a parallax background, and taking in user input. At
this point, you can fire up the player/index.html file and fly your ship left and right using the
arrow keys. Congratulations! You’re well on your way to having your first HTML5 game up-andrunning.
The next chapter builds on these initial pieces of code to add in enemies, levels, and the
rest. Chapter 3, “Enhancing The Game,” finishes this initial game by adding in mobile support.