<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="../../favicon.ico">

    <title>Code++</title>

    <!-- Bootstrap core CSS -->
    <link href="../dist/css/test.css" rel="stylesheet">

    <!-- Bootstrap core CSS -->
    <link href="../dist/css/test-theme.css" rel="stylesheet">

    <link href="../dist/css/highlight-default.css" rel="stylesheet">
    <link href="../dist/css/highlight-theme.css" rel="stylesheet">
	
	<style>.hljs { padding: 0 1.5em; }</style>

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>

  <body>

    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="#">Code++</a>
        </div>
        <div id="navbar" class="collapse navbar-collapse">
          <ul class="nav navbar-nav navbar-right">
            <li class="active"><a href="#">Home</a></li>
            <li><a href="#about">About</a></li>
            <li><a href="#contact">Contact</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>

    <div class="container">

      <div class="page-heading">
        <h1 class="page-title">Section 3</h1>
      </div>

      <h3 class="section-header">Moving game objects with CSS3 transition</h3>
      <p>
We had a glimpse of the CSS3 transition module and transformation module in Chapter 1,<br />
Introducing HTML5 Games, when we were overviewing the new CSS3 features. We often<br />
want to animate the game objects by easing the properties. Transition is the CSS property<br />
designed for this purpose. Imagine we have a playing card on the web page and want to<br />
move it to another position in five seconds. We had to use JavaScript and setup timer and<br />
write our own function to change the position every several milliseconds. By using the<br />
transition property, we just need to specify the start and end styles and the duration.<br />
The browser does all the easing and in-between animations, magically.<br />
<br />
Let's take a look at some examples to understand it.<br />
      </p>

      <div class="panel panel-code-text">
		<div class="panel-heading">
          <h4 class="panel-title"><a href="#content1" data-toggle="collapse" data-parent="#content">Time for action – Moving a playing card around</a></h4>
		</div>
		<div class="panel-collapse collapse" id="content1">
          <div class="panel-body">

<p>In this example, we will place two playing cards on the web page and transform them<br />
to a different position, scale, and rotation. We will tween the transformation by setting<br />
the transition:<br />
<br />
1.  Create a new folder with three files in the following hierarchy. The css3transition.<br />
  css and index.html is empty now and we will add the code later. The jquery-<br />
  1.6.min.js is the jQuery library that we have used in the previous chapter.<br />
</p>
<p><img src="img/ch3-img-001.jpg"></p>
<p>2. We are using two playing card graphic images in this example. The images<br />
are available in the code bundle or you can download them from http://<br />
gamedesign.cc/html5games/css3-basic-transition/images/AK.png<br />
and http://gamedesign.cc/html5games/css3-basic-transition/<br />
images/AQ.png.<br />
<br />
3. Create a new folder named images and place the two card images inside.<br />
<br />
4. The next thing is to code the HTML with two card DIV elements. We will apply<br />
CSS transition style to these two cards elements when the page is loaded:<br />
</p>

<pre><code class="html">
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Getting Familiar with CSS3 Transition&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/css3transition.css&quot; /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;header&gt;
      &lt;h1&gt;Getting Familiar with CSS3 Transition&lt;/h1&gt;
    &lt;/header&gt;
    &lt;section id=&quot;game&quot;&gt;
      &lt;div id=&quot;cards&quot;&gt;
        &lt;div id=&quot;card1&quot; class=&quot;card cardAK&quot;&gt;&lt;/div&gt;
        &lt;div id=&quot;card2&quot; class=&quot;card cardAQ&quot;&gt;&lt;/div&gt;
      &lt;/div&gt; &lt;!-- #cards --&gt;
    &lt;/section&gt; &lt;!-- #game --&gt;
    &lt;footer&gt;
      &lt;p&gt;This is an example of transitioning cards.&lt;/p&gt;
    &lt;/footer&gt;
    &lt;script src=&quot;js/jquery-1.6.min.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
    $(function(){
      $(&quot;#card1&quot;).addClass(&quot;moveAndScale&quot;);
      $(&quot;#card2&quot;).addClass(&quot;rotateRight&quot;);
    });
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;

</code>
</pre>

<p>5. It is time to define the visual styles of the playing cards via CSS. It contains basic CSS<br />
2.1 properties and CSS3 new properties. The new CSS3 properties are highlighted:<br />
</p>
<pre><code class="css">
body {
  background: #aaa;
}
/* defines styles for each card */
.card {
  width: 80px;
  height: 120px;
  margin: 20px;
  background: #efefef;
  position: absolute;
  -webkit-transition: all 1s linear;
}
/* set the card to corresponding playing card graphics */
.cardAK {
  background: url(../images/AK.png);
}
.cardAQ {
  background: url(../images/AQ.png);
}
/* rotate the applied DOM element 90 degree */
.rotateRight {
  -webkit-transform: rotate3d(0,0,1,90deg);
}
/* move and scale up the applied DOM element */
.moveAndScale {
  -webkit-transform: translate3d(150px,150px,0) scale3d(1.5, 1.5,1);
}

</code>
</pre>
<p>6. Let's save all the files and open the index.html in the browser. The two cards<br />
should animate as shown in the following screenshot:<br />
</p>
<p><img src="img/ch3-img-002.jpg"></p>

          </div>
		</div>
      </div>
    
      <h4 class="section-header">Have a go hero</h4>
      <p>
We have translated, scaled, and rotated the playing cards. How about we try changing<br />
different values in the example? There are three axes in the rotate3d function. What will<br />
happen if we rotate the other axis? Experiment with the code yourselves to get familiar with<br />
the transform and transition modules.<br />
      </p>

      <h3 class="section-header">Creating a card-flipping effect</h3>
      <p>
Imagine now we are not just moving the playing card around, but we also want to flip the<br />
card element, just like we flip a real playing card. By using the rotation transform<br />
function, it is now possible to create the card-flipping effect.<br />
      </p>

      <div class="panel panel-code-text">
		<div class="panel-heading">
          <h4 class="panel-title"><a href="#content2" data-toggle="collapse">Time for action – Flipping a card with CSS3</a></h4>
		</div>
		<div class="panel-collapse collapse" id="content2">
          <div class="panel-body">
			  
<p>We are going to start a new project and create a card-flipping effect when we click on the<br />
playing card.:<br />
<br />
1. Let's continue on our previous code example.<br />
<br />
2. The card now contains two faces, a front face and a back face. Replace the following<br />
code into the body tag in the HTML:<br />
</p>

<pre><code class="html">
&lt;section id=&quot;game&quot;&gt;
  &lt;div id=&quot;cards&quot;&gt;
    &lt;div class=&quot;card&quot;&gt;
      &lt;div class=&quot;face front&quot;&gt;&lt;/div&gt;
      &lt;div class=&quot;face back cardAK&quot;&gt;&lt;/div&gt;
    &lt;/div&gt; &lt;!-- .card --&gt;
    &lt;div class=&quot;card&quot;&gt;
      &lt;div class=&quot;face front&quot;&gt;&lt;/div&gt;
      &lt;div class=&quot;face back cardAQ&quot;&gt;&lt;/div&gt;
    &lt;/div&gt; &lt;!-- .card --&gt;
  &lt;/div&gt; &lt;!-- #cards --&gt;
&lt;/section&gt; &lt;!-- #game --&gt;
&lt;script src=&quot;js/jquery-1.6.min.js&quot;&gt;&lt;/script&gt;

</code>
</pre>
			  
<p>3. Then change the CSS external link to the css3flip.css file:<br />
</p>

<pre><code class="html">
&lt;link rel=&quot;stylesheet&quot; href=&quot;css/css3flip.css&quot; /&gt;

</code>
</pre>
			  
<p>4. Now let's add the styles to the css3flip.css:<br />
</p>

<pre><code class="css">
#game {
  background: #9c9;
  padding: 5px;
}
/* Define the 3D perspective view and dimension of each card. */
.card {
  -webkit-perspective: 600;
  width: 80px;
  height: 120px;
}

</code>
</pre>
			  
<p>5. There are two faces on each card. We are going to rotate the face late. Therefore,<br />
we define how the face transits by CSS3 transition property. We also hide the<br />
back face visibility. We will look at the detail of this property later:<br />
</p>

<pre><code class="css">
.face {
  border-radius: 10px;
  width: 100%;
  height: 100%;
  position: absolute;
  -webkit-transition: all .3s;
  -webkit-backface-visibility: hidden;
}

</code>
</pre>
			  
<p>6. Now it is time to style each individual face. The front face has a higher z-index than<br />
the back face:<br />
</p>

<pre><code class="css">
.front {
  background: #966;
  z-index: 10;
}
.back {
  background: #eaa;
  -webkit-transform: rotate3d(0,1,0,-180deg);
  z-index: 8;
}

</code>
</pre>

<p>7. When we flip the card, we rotate the front face to back and back face to front.<br />
We also swap the z-index of the front and back face:<br />
</p>

<pre><code class="css">
.card-flipped .front {
  -webkit-transform: rotate3d(0,1,0,180deg);
  z-index: 8;
}
.card-flipped .back {
  -webkit-transform: rotate3d(0,1,0,0deg);
  z-index: 10;
}
.cardAK {
  background: url(../images/AK.png);
}
.cardAQ {
  background: url(../images/AQ.png);
}

</code>
</pre>

<p>8. Next, we will add logic after loading the jQuery library to toggle the card-flipped<br />
status when clicking on the card:<br />
</p>

<pre><code class="html">
&lt;script&gt;
$(function(){
  $(&quot;#cards&quot;).children().each(function(index) {
    // listen the click event on each card DIV element.
    $(this).click(function() {
      // add the class &quot;card-flipped&quot;.
      // the browser will animate the styles between current state and card-flipped state.
      $(this).toggleClass(&quot;card-flipped&quot;);
    });
  });
});
&lt;/script&gt;

</code>
</pre>

<p>9. The styles and the scripts are now ready. Let's save all the files and preview it in our<br />
web browser. Click the playing card to flip it over and click again to flip back.<br />
</p>

<p><img src="img/ch3-img-003.jpg"></p>

          </div>
		</div>
      </div>
    
      <h4 class="section-header">What just happened?</h4>
      <p>
We have created a card-flipping effect toggled by a mouse click. The example made use of<br />
several CSS transforms properties and JavaScript for handling the mouse click event.<br />
      </p>

      <h3 class="section-header">Toggling class with jQuery toggleClass function</h3>
      <p>
We apply the class card-flipped to the card element when the mouse is clicked on the<br />
card. On the second click, we want to remove the applied card-flipped style so the card flips<br />
back again. This is called toggling a class style.<br />
<br />
jQuery provides us with a handy function named toggleClass to add or remove classes<br />
automatically, depending on whether the class is applied or not.<br />
<br />
To use the function, we simply pass the classes that we want to toggle as an argument.<br />
<br />
For example, the following code adds or removes the card-flipped class to an element<br />
with ID card1:<br />
      </p>
	  
	  <pre><code class="javascript">
$(&quot;#card1&quot;).toggleClass(&quot;card-flipped&quot;);
	  </code>
	  </pre>
	  
      <p>
The toggleClass function accepts toggle from more than one class at the sample time.<br />
We can pass in several class names and separate them by using space. Here is an example<br />
of toggling two classes at the same time:<br />
      </p>
	  
	  <pre><code class="javascript">
$(&quot;#card1&quot;).toggleClass(&quot;card-flipped scale-up&quot;);
	  </code>
	  </pre>

      <h3 class="section-header">Controlling the visibility of overlapped elements by z-index</h3>
      <p>
Normally, all elements in a web page are distributed and presented without overlapping.<br />
Designing a game is a different story. We always need to deal with overlapped elements and<br />
hide them (or part of them) on purpose. Z-index, a CSS 2.1 property, helps us to control the<br />
visibility behaviors when more than one element is overlapped.<br />
<br />
In this example, we have two faces for each card, the front and the back face. The two faces<br />
are placed in the exact position. They overlap each other. The Z-index property defines which<br />
element is on top and which is behind. The elements with a higher z-index go in front of<br />
elements with a lower z-index. When they overlap, the one with the higher z-index will cover<br />
the one with the lower z-index. The following screenshot demonstrates the z-index behavior:<br />
      </p>
	  
	  <p><img src="img/ch3-img-004.jpg"></p>
	  
	  <pre><code class="css">
.front {
  z-index: 10;
}
.back {
  z-index: 8;
}
	  </code>
	  </pre>
	  
      <p>
While in a flipped state, the front face changes to a lower z-index than the back face.<br />
The back face now covers the front face:<br />
      </p>
	  
	  <p><img src="img/ch3-img-004.jpg"></p>
	  
	  <pre><code class="css">
.card-flipped .front {
  z-index: 8;
}
.card-flipped .back {
  z-index: 10;
}
	  </code>
	  </pre>

      <h3 class="section-header">Introducing CSS perspective property</h3>
      <p>
CSS3 lets us present elements in 3D. We have been able to transform the elements in 3D<br />
space. The perspective property defines how the 3D perspective view looks. You can treat<br />
the value as far as you are looking at the object. The closer you are, the more perspective<br />
distortion there is on the viewing object.<br />
<br />
The following two 3D cubes demonstrate how different perspective values change the<br />
perspective view of the element:<br />
      </p>
	  
	  <p><img src="img/ch3-img-005.jpg"></p>
	  
      <p>
You can view this experiment by going to the following address in Safari:<br />
<br />
http://gamedesign.cc/html5games/perspective-cube/<br />
      </p>

      <h4 class="section-header">Have a go hero</h4>
      <p>
The cube is created by putting six faces together with 3D transforms applied to each face.<br />
It used the techniques we've discussed. Try to create a cube and experiment with the<br />
perspective property.<br />
<br />
The following web page gives a comprehensive explanation on creating the CSS3 cube, and<br />
also discusses controlling the rotation of the cube through the keyboard:<br />
<br />
http://www.paulrhayes.com/2009-07/animated-css3-cube-interface-using-<br />
3d-transforms/<br />
      </p>

      <h3 class="section-header">Introducing backface-visibility</h3>
      <p>
Before the backface-visibility is introduced, all elements on the page present their front face<br />
to the visitor. Actually, there was no concept of the front face or back face of the element<br />
because it was the only choice. While CSS3 introduces the rotation in three axes, we can<br />
rotate an element so that its face is on the back. Try looking at your palm and rotating your<br />
wrist, your palm turns and you see the back of your palm. This happens to the rotated<br />
elements too.<br />
<br />
CSS3 introduces a property named backface-visibility to define whether we can<br />
see the back face of the element or not. By default, it is visible. The following screenshots<br />
demonstrate the two different behaviors of the backface-visibility property.<br />
      </p>
	  
	  <p><img src="img/ch3-img-006.jpg"></p>

      <h3 class="section-header">Creating a card matching memory game</h3>
      <p>
We have gong through some CSS basic techniques. Let's make a game with the techniques.<br />
We are going to make a card game. The card game makes use of transform to flip the card,<br />
transition to move the card, JavaScript to hold the logic, and a new HTML5 feature called<br />
custom data attribute. Don't worry, we will discuss each component step by step.<br />
      </p>

      <h3 class="section-header">Downloading the sprites sheet of playing cards</h3>
      <p>
In the card-flipping example, we were using two different playing card graphics. Now we<br />
prepare the whole deck of playing card graphics. Although we only use six playing cards in<br />
the matching game, we prepare the whole deck so we can reuse these graphics in other<br />
playing card games that we may create.<br />
<br />
There are 52 playing cards in a deck and we have one more graphic for the backside. Instead<br />
of using 53 separated files, it is good practice to put separated graphics into one big sprite<br />
sheet file. The term sprite sheet was from an old computer graphics technique that loaded<br />
one graphics texture into memory and displayed part of the graphics.<br />
<br />
One benefit of using a big sprite sheet instead of separated image files is that we can<br />
reduce the amount of HTTP requests. When the browser loads the web page, it creates a<br />
new HTTP request to load each external resource, including JavaScript files, CSS files, and<br />
images. It takes quite a lot of time to establish a new HTTP request for each separated small<br />
file. Combining the graphics into one file, largely reduces the amount of requests and thus<br />
improves the responsiveness of the game when loading in the browser.<br />
<br />
Another benefit for placing graphics into one file is to avoid the overhead of the file format<br />
header. The size of a 53 images sprite sheet is less than the sum of 53 different images with<br />
the file header in each file.<br />
<br />
The following deck of playing cards graphics is drawn and aligned in Adobe Illustrator. You<br />
can download it from http://gamedesign.cc/html5games/css3-matching-game/<br />
images/deck.png.<br />
      </p>

      <h3 class="section-header">Setting up the game environment</h3>
      <p>
The graphics are ready, we will then need to set up a static page with the game objects<br />
prepared and placed on the game area. It is easier for adding game logic and interaction later:<br />
      </p>

      <div class="panel panel-code-text">
		<div class="panel-heading">
          <h4 class="panel-title"><a href="#content3" data-toggle="collapse">Time for action – Preparing the card matching game</a></h4>
		</div>
		<div class="panel-collapse collapse" id="content3">
          <div class="panel-body">

<p>Before adding the complicated game logic to our matching game, let's prepare the HTML<br />
game structure and prepare all the CSS styles:<br />
<br />
1. Let's continue on our code. Replace the index.html file with the following HTML:<br />
</p>

<pre><code class="html">
&lt;!DOCTYPE html&gt;
&lt;html lang=en&gt;
&lt;head&gt;
  &lt;meta charset=utf-8&gt;
  &lt;title&gt;CSS3 Matching Game&lt;/title&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;css/matchgame.css&quot; /&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;header&gt;
    &lt;h1&gt;CSS3 Matching Game&lt;/h1&gt;
  &lt;/header&gt;
  &lt;section id=&quot;game&quot;&gt;
    &lt;div id=&quot;cards&quot;&gt;
      &lt;div class=&quot;card&quot;&gt;
        &lt;div class=&quot;face front&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;face back&quot;&gt;&lt;/div&gt;
      &lt;/div&gt; &lt;!-- .card --&gt;
    &lt;/div&gt; &lt;!-- #cards --&gt;
  &lt;/section&gt; &lt;!-- #game --&gt;
  &lt;footer&gt;
    &lt;p&gt;This is an example of creating a matching game with CSS3.&lt;/p&gt;
  &lt;/footer&gt;
  &lt;script src=&quot;js/jquery-1.6.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;js/html5games.matchgame.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;

</code>
</pre>

<p>2. In order to make the game more appealing, I prepared background images for the<br />
game table and the page. These graphic assets can be found in the code example<br />
bundle. The background images are optional and they will not affect the gameplay<br />
and the logic of the matching game.<br />
<br />
3. We will also place the deck sprite sheet graphics into the images folder. Download<br />
the deck.png file from http://gamedesign.cc/html5games/css3-<br />
matching-game/images/deck.png and save it into the images folder.<br />
<br />
4. Let's add style to the matching game before writing any logic. Open matchgame.<br />
css and add the following body styles:<br />
</p>

<pre><code class="css">
body {
  text-align: center;
  background: #a46740 url(../images/bg.jpg);
}

</code>
</pre>

<p>5. Continue to add the styles to the game element. It will be the main area<br />
of the game:<br />
</p>

<pre><code class="css">
#game {
  border-radius: 10px;
  border: 1px solid #666;
  background: #232 url(../images/table.jpg);
  width: 500px;
  height: 460px;
  margin: 0 auto;
  display: box;
  box-pack: center;
  box-align: center;
}

</code>
</pre>

<p>6. We will put all card elements into a parent DOM named cards. By doing this, we<br />
can easily center all cards to the game area:<br />
</p>

<pre><code class="css">
#cards {
  position: relative;
  width: 380px;
  height: 400px;
}

</code>
</pre>

<p>7. For each card, we define a perspective property to give it a visual depth effect:<br />
</p>

<pre><code class="css">
.card {
  -webkit-perspective: 600;
  width: 80px;
  height: 120px;
  position: absolute;
  -moz-transition: all .3s;
  -webkit-transition: all .3s;
  transition: all .3s;
}

</code>
</pre>

<p>8. There are two faces on each card. The face will be rotated later and we will define<br />
the transition properties to animate the style changes. We also want to make sure<br />
the back face is hidden:<br />
</p>

<pre><code class="css">
.face {
  border-radius: 10px;
  width: 100%;
  height: 100%;
  position: absolute;
  -webkit-transition-property: opacity, transform, box-shadow;
  -webkit-transition-duration: .3s;
  -webkit-backface-visibility: hidden;
}

</code>
</pre>

<p>9. Then we set the front and back face styles. They are almost the same as the<br />
flipping card example, except that we are now giving them background images<br />
and box shadows:<br />
</p>

<pre><code class="css">
.front {
  background: #999 url(../images/deck.png) 0 -480px;
  z-index: 10;
}
.back {
  background: #efefef url(../images/deck.png);
  -webkit-transform: rotate3d(0,1,0,-180deg);
  z-index: 8;
}
.card:hover .face, .card-flipped .face {
  -webkit-box-shadow: 0 0 10px #aaa;
}
.card-flipped .front {
  -webkit-transform: rotate3d(0,1,0,180deg);
  z-index: 8;
}
.card-flipped .back {
  -webkit-transform: rotate3d(0,1,0,0deg);
  z-index: 10;
}

</code>
</pre>

<p>10. When any card is removed, we want to fade it out. Therefore, we declare a<br />
card-removed class with 0 opacity:<br />
</p>

<pre><code class="css">
.card-removed {
  opacity: 0;
}

</code>
</pre>

<p>11. In order to show different playing card graphics from the sprite sheet of the card<br />
deck, we clip the background of the card into different background positions:<br />
</p>

<pre><code class="css">
.cardAQ {background-position: -880px 0;}
.cardAK {background-position: -960px 0;}
.cardBQ {background-position: -880px -120px;}
.cardBK {background-position: -960px -120px;}
.cardCQ {background-position: -880px -240px;}
.cardCK {background-position: -960px -240px;}
.cardDQ {background-position: -880px -360px;}
.cardDK {background-position: -960px -360px;}

</code>
</pre>

<p>12. We have defined a lot of CSS styles. It is now time for the JavaScript logic.<br />
Open the html5games.matchgame.js file and put the following code inside:<br />
</p>

<pre><code class="css">
$(function(){
  // clone 12 copies of the card
  for(var i=0;i&lt;11;i++){
    $(&quot;.card:first-child&quot;).clone().appendTo(&quot;#cards&quot;);
  }
  // initialize each card's position
  $(&quot;#cards&quot;).children().each(function(index) {
    // align the cards to be 4x3 ourselves.
    $(this).css({
      &quot;left&quot; : ($(this).width() + 20) * (index % 4),
      &quot;top&quot; : ($(this).height() + 20) * Math.floor(index / 4)
    });
  });
});

</code>
</pre>

<p>13. Now save all files and preview the game in the browser. The game should be well<br />
styled and 12 cards should appear in the center. However, we cannot click on the<br />
cards yet because we have not set any interaction logic to the cards.<br />
</p>

		  </div>
		</div>
	  </div>

    </div><!-- /.container -->


    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
    <script src="../dist/js/test.min.js"></script>
    <script src="../dist/js/highlight.pack.js"></script>
    <script>
    hljs.configure({ tabReplace: '  ' });
    hljs.initHighlightingOnLoad();
    </script>
  </body>
</html>
