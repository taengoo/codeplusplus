
SECTION 5: Events and Streams

5.1 Classical Inheritance in JavaScript
	- Arriving at an Inheritance Pattern
	- The Constructor Property
	- The Proper Node.js Way
	- Overriding Functions in Child Classes
	- Checking Inheritance Chain
	- Deeper Understanding of the Internals of util.inherits
5.2 Node.js Events
	- EventEmitter class
	- Creating Your Own Event Emitters
	- Process Events
5.3 Streams
	- Pipe
	- Consuming Readable Streams
	- Writing to Writable Streams
	- Creating Your Own Stream
5.4 Summary


----
SECTION 5: Events and Streams
----

Before we examine specific areas of Node.js development, we need to address a few more core concepts about JavaScript in general and Node.js in particular. Node.js is focused on being the best-performing, simplest way to create server applications. Events and streams play an important role in achieving this goal.

Node.js is single-threaded; we have already discussed advantages of this fact. Due to this evented nature of Node.js, it has first-class support for an event subscription/unsubscription pattern. This pattern is very similar to the way you would handle events using JavaScript in the browser.

Streaming data is one of those areas that fit very naturally in Node.js. Streams are great for improving user experience plus decreasing server resource utilization.

To understand how we can create our own event emitters and streams, we first need to understand JavaScript inheritance.


----
5.1 Classical Inheritance in JavaScript
----
We saw how prototype works in Chapter 2. JavaScript supports prototypal inheritance. In JavaScript, a member is looked up on the current item (such as item.foo), followed by its prototype (item.__proto__.foo), which is followed by its prototype’s prototype (item.__proto__.__proto__.foo), and so on until the prototype itself (for example, item.__proto__.__proto__.__proto__) is null. We have already seen how this can be used to emulate a classical object oriented class construct in JavaScript. Now let’s look at how it can be used to implement classical object oriented inheritance.

----
Arriving at an Inheritance Pattern
----
Let’s create an Animal class. It has a simple member function called walk. We’ve already discussed that `this` within a function refers to the newly created object when a function is called with the `new` operator (for example, `new Animal`). We also discussed that the prototype member of the constructor function (Animal.prototype) is referenced by the object prototype (animal.__proto__) because of using the new operator. (See Listing 5-1).

Listing 5-1. oo/1animal.js
function Animal(name) {
    this.name = name;
}
Animal.prototype.walk = function (destination) {
    console.log(this.name, 'is walking to', destination);
};

var animal = new Animal('elephant');
animal.walk('melbourne'); // elephant is walking to melbourne

To better understand how the lookup is performed on `animal.walk`, have a look at the diagram in Figure 5-1.

Figure 5-1. Sample lookup of member from prototype

Now let’s inherit all of the Animal class functionality in a new class, for example, Bird. To do this, we need to do two things:
-    Call the Animal constructor from the Bird constructor. This ensures that the properties are set up properly for the Bird object (Animal.name in our example).
-    Find a way to make all parent (Animal) prototype members (for example, __proto__.walk) a member of the child (Bird) instance’s prototype’s prototype. This will allow Bird instances (for example, bird) to have their own functions on their own prototype (bird.__proto__.fly) and the parent members on their prototype’s prototype (bird.__proto__.__proto__.walk). This is called setting up a prototype chain.

We will begin by fleshing out the Bird class. Based on the algorithm, it will look like the code in Listing 5-2.

Listing 5-2. Building Up to Inheritance
function Bird(name){
    // Call the Animal constructor
}
// Setup the prototype chain between Bird and Animal

// Finally create child instance
var bird = new Bird('sparrow');

Calling the Parent Constructor
----
We cannot simply call the parent Animal constructor from Bird. That is because if we do so, then `this` within Animal will not refer to the newly created Bird object (created from new Bird). Hence, we need to force the meaning of this within the Animal function to point to the value of this inside the Bird function. Fortunately, we can force the meaning by using the '.call' member function available on all JavaScript functions (it comes from Function.prototype). Listing 5-3 presents a demonstration of the call member. As usual, the comments explain what is going on.

Listing 5-3. oo/2call.js
var foo = {};
var bar = {};

// A function that uses `this`
function func(val) {
    this.val = val;
}

// Force this in func to be foo
func.call(foo, 123);

// Force this in func to be bar
func.call(bar, 456);

// Verify:
console.log(foo.val); // 123
console.log(bar.val); // 456

You can see that we forced `this` inside the `func` function to be foo and then bar. Great! Now that we know how to force this, let’s use it to call the parent, as shown in Listing 5-4.

Listing 5-4. Calling the Parent Constructor
function Bird(name){
    Animal.call(this,name);

    // Any additional initialization code you want
}
// Copy all Animal prototype members to Bird

You use this pattern (Parent.call(this, /* additional args */)) every time you need to call a parent constructor. Now you have a firm functional understanding of why this is.

Setting Up the Prototype Chain
----
We need a mechanism so that when we create a new Bird (such as, bird = new Bird), its prototype chain contains all the parent prototype functions (for example, bird.__proto__.__proto__.walk). This can be done quite simply if we do Bird.prototype.__proto__ = Animal.prototype.

This process works because when we will do bird = new Bird, we will effectively get bird.__proto__.__proto__ = Animal.prototype and that will make the parent prototype members (for example, Animal.prototype.walk) available on the child prototype (bird.__proto__.__proto__.walk), which was the desired result. Listing 5-5 shows a simple code sample.

Listing 5-5. oo/3prototype.js
// Animal Base class
function Animal(name) {
    this.name = name;
}
Animal.prototype.walk = function (destination) {
    console.log(this.name, 'is walking to', destination);
};

var animal = new Animal('elephant');
animal.walk('melbourne'); // elephant is walking to melbourne

// Bird Child class
function Bird(name) {
    Animal.call(this, name);
}
Bird.prototype.__proto__ = Animal.prototype;
Bird.prototype.fly = function (destination) {
    console.log(this.name, 'is flying to', destination);
}

var bird = new Bird('sparrow');
bird.walk('sydney'); // sparrow is walking to sydney
bird.fly('melbourne'); // sparrow is flying to melbourne

To understand how an inherited member (bird.walk in our example) lookup is performed, take a look at Figure 5-2.

Figure 5-2. Sample lookup of a member from a prototype chain

Note that manually modifying the __proto__ property is not recommended since it isn’t a part of the ECMAScript standard. We will discuss a more standard way of setting the prototype shortly, but the principle shown here makes you an expert of JavaScript prototypal inheritance.

----
The Constructor Property
----
By default, every function gets a member called `prototype`, which we have already seen. By default, this member has a constructor property that points to the function itself. Listing 5-6 demonstrates this.

Listing 5-6. oo/4constructor/1basic.js
function Foo() { }
console.log(Foo.prototype.constructor === Foo); // true

What is the advantage of having this property? After you create an instance using a function (for example, instance = new Foo), you can get access to the constructor using a simple lookup instance.constructor (which is really going to be looking at instance.__proto__.constructor). Listing 5-7 shows this in an example where we use the property name of named functions (function Foo) to log out what created the object.

Listing 5-7. oo/4constructor/2new.js
function Foo() { }

var foo = new Foo();
console.log(foo.constructor.name); // Foo
console.log(foo.constructor === Foo); // true

Having knowledge of the constructor property enables you to do runtime reflection on instances if you need to.

----
The Proper Node.js Way
----
The util core module (require('utils')) we discussed in Chapter 3 provides a lovely little function to create the prototype chain for us so you don’t need to mess with `__proto__` (the nonstandard property) yourself. The function is called `inherits` and takes a child class followed by parent class, as shown in the example in Listing 5-8. Bird class extends the Animal class, which we saw earlier.

Listing 5-8. oo/5nodejs/util.js
// util function
var inherits = require('util').inherits;

// Bird Child class
function Bird(name) {
    // Call parent constructor
    Animal.call(this, name);

    // Additional construction code
}
inherits(Bird, Animal);

// Additional member functions
Bird.prototype.fly = function (destination) {
    console.log(this.name, 'is flying to', destination);
}

var bird = new Bird('sparrow');
bird.walk('sydney'); // sparrow is walking to sydney
bird.fly('melbourne'); // sparrow is flying to melbourne

There are two things of note:
-    Call the parent constructor: Animal.call(this, /* any original arguments */)
-    Set up the prototype chain: inherits(Bird, Animal);

Simple enough to become second nature, this is all you need to do to inherit classes!

----
Overriding Functions in Child Classes
----
To override parent functions but still utilize some of the original functionality, simply do the following:
-    Create a function on the child prototype with the same name.
-    Call the parent function similar to the way we called the parent constructor, basically using the Parent.prototype.memberfunction.call(this, /*any original args*/) syntax.

Listing 5-9 demonstrates this.

Listing 5-9. oo/6override.js
// util function
var inherits = require('util').inherits;

// Base
function Base() { this.message = "message"; };
Base.prototype.foo = function () { return this.message + " base foo" };

// Child
function Child() { Base.call(this); };
inherits(Child, Base);

// Overide parent behaviour in child
Child.prototype.foo = function () {
    // Call base implementation + customize
    return Base.prototype.foo.call(this) + " child foo";
}

// Test:
var child = new Child();
console.log(child.foo()); // message base foo child foo

We simply created the child function Child.prototype.foo and called the parent function from within Base.prototype.foo.call(this).

----
Checking Inheritance Chain
----
Setting up a prototype chain (__proto__.__proto__) as we have seen has an additional advantage in that it allows you to check if a particular object instance is of a particular class, or its parent class, or its parent’s parent class, and so on. This is done using the instanceof operator.

In pseudocode when you do someObj instanceof Func the you use this algorithm:
-    Check someObj.__proto__ == Func.prototype and if so return true.
-    If not, check someObj.__proto__.__proto__ == Func.prototype and if so return true.
-    Repeat moving up the prototype chain.
-    If __proto__ is null and we haven’t found a match, return false.

From the pseudocode, you can see that it is very similar to how a property lookup is performed. We travel up the prototype chain until we find a __proto__ equal to the Func.prototype. Finding a match is an indication of the new operator being used on the specified Func as the new operator copies prototype to __proto__. A quick demonstration of using instanceof is shown in Listing 5-10.

Listing 5-10. oo/7instanceof.js
var inherits = require('util').inherits;

function A() { }
function B() { }; inherits(B, A);
function C() { }

var b = new B();
console.log(b instanceof B); // true because b.__proto__ == B.prototype
console.log(b instanceof A); // true because b.__proto__.__proto__ == A.prototype
console.log(b instanceof C); // false

----
Deeper Understanding of the Internals of util.inherits
----
You do not need to go through this section, but it is worthwhile just so you can sit at the cool kids’ table. We said that setting __proto__ manually is not recommended as it is not a part of the standardized JavaScript.

Fortunately, there is a function in JavaScript that can create a blank object with a specified __proto__ already set. The function is called Object.create and the way it works is shown in Listing 5-11.

Listing 5-11. oo/8internals/1check.js
var foo = {};
var bar = Object.create(foo);
console.log(bar.__proto__ === foo); // true

In this example, we simply verified that the newly created object (that is, bar) has its __proto__ member set to what we passed into Object.create (in other words, foo). It can be used for inheritance as shown in Listing 5-12.

Listing 5-12. oo/8internals/2inherit.js
// Animal Base class
function Animal() {
}
Animal.prototype.walk = function () {
    console.log('walking');
};

// Bird Child class
function Bird() {
}
Bird.prototype = Object.create(Animal.prototype);

var bird = new Bird();
bird.walk();

Compared to the original non-standard __proto__ mechanism we showed before, here we simply replaced Bird.prototype.__proto__ = Animal.prototype with what is effectively Bird.prototype = { __proto__ : Animal.prototype }.

This mechanism correctly inherits the members from the parent, but it creates one slight problem. When we reassigned Bird.prototype, the constructor information that was there in Bird.prototype.constructor was lost because we reassigned Bird.prototype to a completely new object. To bring the constructor property back, a simple solution is to pass a second parameter to Object.create, which specifies additional properties to add to the object to be created. In Listing 5-13, we specify that the constructor is a property that points to the function itself, which is what the Bird.prototype.constructor was originally (remember that Bird.prototype.constructor === Bird).

Listing 5-13. oo/8internals/3inheritBetter.js
// Animal Base class
function Animal() {
}
Animal.prototype.walk = function () {
    console.log('walking');
};

// Bird Child class
function Bird() {
}
Bird.prototype = Object.create(Animal.prototype, {
    constructor: {
        value: Bird,
        enumerable: false,
        writable: true,
        configurable: true
    }
});

var bird = new Bird();
bird.walk();
console.log(bird.constructor === Bird); // true

And this is exactly the implementation found in Node.js util module (which is written in JavaScript). The implementation straight from the source is shown in Listing 5-14.

Listing 5-14. Code Retrieved from Node.js source util.js
exports.inherits = function(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = Object.create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
};

One more thing that the inherits function does is it adds a property super_ to the child class, which points to the parent class. This is simply for convention so that you know that this child function prototype has received members from this super_ class when debugging or writing reflection-based code.

Mastering inheritance is so involved because JavaScript was designed with simple prototypal inheritance. We are simply utilizing the power offered by it to mimic a traditional OO hierarchy.


----
5.2 Node.js Events
----
We already have a way to execute some code based on some occurrence (event) using callbacks. A more general concept for handling occurrences of significance is events. An event is like a broadcast, while a callback is like a handshake. A component that raises events knows nothing about its clients, while a component that uses callbacks knows a great deal. This makes events ideal for scenarios where the significance of the occurrence is determined by the client. Maybe the client wants to know, maybe it doesn’t. Registering multiple clients is also simpler with this even as we will see in this section.

Node.js comes with built-in support for events baked into the core events module. As always, use require('events') to load the module. The events module has one simple class "EventEmitter", which we present next.

----
EventEmitter class
----
EventEmitter is a class designed to make it easy to emit events (no surprise there) and subscribe to raised events. Listing 5-15 provides a small code sample where we subscribe to an event and then raise it.

Listing 5-15. events/1basic.js
var EventEmitter = require('events').EventEmitter;

var emitter = new EventEmitter();

// Subscribe
emitter.on('foo', function (arg1, arg2) {
    console.log('Foo raised, Args:', arg1, arg2);
});

// Emit
emitter.emit('foo', { a: 123 }, { b: 456 });

As shown in the example, you can create a new instance with a simple `new EventEmitter` call. To subscribe to events, you use the `on` function passing in the event name (always a string) followed by an event handling function (also called a listener). Finally, we raise an event using the emit function passing in the event name followed by any number of arguments we want passed into the listeners (in Listing 5-15 we used two arguments for demonstration).

Multiple Subscribers
----
As we mentioned previously, having built-in support for multiple subscribers is one of the advantages of using events. Listing 5-16 is a quick sample where we have multiple subscribers for an event.

Listing 5-16. events/2multiple.js
var EventEmitter = require('events').EventEmitter;
var emitter = new EventEmitter();

emitter.on('foo', function () {
    console.log('subscriber 1');
});

emitter.on('foo', function () {
    console.log('subscriber 2');
});

// Emit
emitter.emit('foo');

Another thing to note in this sample is the fact that the listeners are called in the order that they registered for the event. This is a nice consequence of the single-threaded nature of Node.js, which makes it easier for you to reason about your code. Additionally, any arguments passed in for the event are shared between the various subscribers, as demonstrated in Listing 5-17.

Listing 5-17. events/3shared.js
var EventEmitter = require('events').EventEmitter;
var emitter = new EventEmitter();

emitter.on('foo', function (ev) {
    console.log('subscriber 1:', ev);
    ev.handled = true;
});

emitter.on('foo', function (ev) {
    if (ev.handled) {
        console.log('event already handled');
    }
});

// Emit
emitter.emit('foo', { handled: false });

In this sample, the first listener modified the passed event argument and the second listener got the modified object. You can potentially use this fact for getting you out of a tricky situation, but I highly caution against it. The reason for showing this sharing of the event arguments is to warn you about the dangers of modifying the event object directly in a listener.

Unsubscribing
----
The next question to ask is how do we unsubscribe from an event. EventEmitter has a removeListener function that takes an event name followed by a function object to remove from the listening queue. One thing to note is that you must have a reference to the function you want removed from the listening queue and, therefore, should not use an anonymous (inline) function. This is because two functions in JavaScript are not equal if their bodies are the same, as shown below in Listing 5-18, since these are two different and distinct function objects.

Listing 5-18. Sample to Demonstrate Function Inequality
$ node -e "console.log(function(){} == function(){})"
false

Listing 5-19 shows how you can unsubscribe a listener.

Listing 5-19. events/4unsubscribe.js
var EventEmitter = require('events').EventEmitter;
var emitter = new EventEmitter();

var fooHandler = function () {
    console.log('handler called');

    // Unsubscribe
    emitter.removeListener('foo',fooHandler);
};

emitter.on('foo', fooHandler);

// Emit twice
emitter.emit('foo');
emitter.emit('foo');

In this sample, we unsubscribe from the event after it is raised once. As a result, the second event goes unnoticed.

Has This Event Ever Been Raised?
----
It is a common use case that you don’t care about every time an event is raised—just that it is raised once. For this, EventEmitter provides a function `once` that calls the registered listener only once. Listing 5-20 demonstrates its usage.

Listing 5-20. events/5once.js
var EventEmitter = require('events').EventEmitter;
var emitter = new EventEmitter();

emitter.once('foo', function () {
    console.log('foo has been raised');
});

// Emit twice
emitter.emit('foo');
emitter.emit('foo');

The event listener for foo will only be called once.

Listener Management
----
There are a few additional utility functions available on the EventEmitter that you need to be aware of to be a Node.js event-handling expert.

EventEmitter has a member function, listeners, that takes an event name and returns all the listeners subscribed to that event. This can be very useful when you are debugging event listeners. Listing 5-21 demonstrates its usage.

Listing 5-21. events/6listeners.js
var EventEmitter = require('events').EventEmitter;
var emitter = new EventEmitter();

emitter.on('foo', function a() { });
emitter.on('foo', function b() { });

console.log(emitter.listeners('foo')); // [ [Function: a], [Function: b]]

EventEmitter instances also raise a `newListener` event whenever a new listener is added and `removeListener` whenever a listener is removed, which can help you out in tricky situations such as when you want to track down the instant an event listener is registered/unregistered. It can also be useful for any management you want to do when listeners are added or removed, as shown in Listing 5-22.

Listing 5-22. events/7listenerevents.js
var EventEmitter = require('events').EventEmitter;
var emitter = new EventEmitter();

// Listener addition / removal notifications
emitter.on('removeListener', function (eventName, listenerFunction) {
    console.log(eventName, 'listener removed', listenerFunction.name);
});
emitter.on('newListener', function (eventName, listenerFunction) {
    console.log(eventName, 'listener added', listenerFunction.name);
});

function a() { }
function b() { }

// Add
emitter.on('foo', a);
emitter.on('foo', b);

// Remove
emitter.removeListener('foo', a);
emitter.removeListener('foo', b);

Note that if you add a `removeListener` after adding a handler for `newListener`, you will get notified about the `removeListener` addition as well, which is why it is conventional to add the removeListener event handler first as we did in this sample.

EventEmitter Memory Leaks
----
A common source of memory leaks when working with events is subscribing to events in a callback but forgetting to unsubscribe at the end. By default, EventEmitter will tolerate 10 listeners for each event type—anymore and it will print a warning to the console. This warning is specifically for your assistance. All you code will continue to function. In other words, more listeners will be added without warning and all listeners will be called when an event is raised, as shown in Listing 5-23.

Listing 5-23. events/8maxEventListeners.js
var EventEmitter = require('events').EventEmitter;
var emitter = new EventEmitter();

var listenersCalled = 0;

function someCallback() {
    // Add a listener
    emitter.on('foo', function () { listenersCalled++ });

    // return from callback
}

for (var i = 0; i < 20; i++) {
    someCallback();
}
emitter.emit('foo');
console.log('listeners called:', listenersCalled); // 20

The output from the application is shown in Listing 5-24. You can see that despite the warning, all 20 listeners were called when we emitted the event.

Listing 5-24. Running the Max Event Listeners Demo
$ node 8maxEventListeners.js
(node) warning: possible EventEmitter memory leak detected. 11 listeners added.
Use emitter.setMaxListeners() to increase limit.
Trace
    at EventEmitter.addListener (events.js:160:15)
    at someCallback (/path/to/8maxEventListeners.js:8:13)
    at Object.<anonymous> (/path/to/8maxEventListeners.js:14:5)
    at Module._compile (module.js:456:26)
    at Object.Module._extensions..js (module.js:474:10)
    at Module.load (module.js:356:32)
    at Function.Module._load (module.js:312:12)
    at Function.Module.runMain (module.js:497:10)
    at startup (node.js:119:16)
    at node.js:902:3
listeners called: 20

A common cause of this memory leak is forgetting to unsubscribe for the event when in an error condition of a callback. A simple solution is to create a new event emitter in the callback. This way the event emitter is not shared, and it is disposed along with all of its subscribers when the callback terminates.

Finally, there are cases where having more than 10 listeners is a valid scenario. In such cases, you can increase a limit for this warning using the setMaxListeners member function, as shown in Listing 5-25.

Listing 5-25. events/9setMaxListeners.js
var EventEmitter = require('events').EventEmitter;
var emitter = new EventEmitter();

// increase limit to 30
emitter.setMaxListeners(30);

// subscribe 20 times
// No warning will be printed
for (var i = 0; i < 20; i++) {
    emitter.on('foo', function () { });
}
console.log('done');

Note that this increases the limit for all event types on this event emitter. Also, you can pass in 0 to allow an unlimited number of event listeners to be subscribed without warning.

Node.js tries to be safe by default; memory leaks can weigh heavily when working on a server environment, which is why this warning message exists.

Error Event
----
An 'error' event is treated as a special exceptional case in Node.js. If there is no listener for it, then the default action is to print a stack trace and exit the program. Listing 5-26 gives a quick sample to demonstrate this.

Listing 5-26. events/10errorEvent.js
var EventEmitter = require('events').EventEmitter;
var emitter = new EventEmitter();

// Emit an error event
// Since there is no listener for this event the process terminates
emitter.emit('error', new Error('Something horrible happened'));

console.log('this line never executes');

If you run this code, you will get an output, as shown in Listing 5-27. You should use an Error object if you ever need to raise an error event, as we did in this example. You can also see from the example that the last line containing the console.log never executes as the process terminated.

Listing 5-27. Sample Run of Error Event Sample
$ node 10errorEvent.js

events.js:72
        throw er; // Unhandled 'error' event
              ^
Error: Something horrible happened
    at Object.<anonymous> (/path/to/10errorEvent.js:6:23)
    at Module._compile (module.js:456:26)
    at Object.Module._extensions..js (module.js:474:10)
    at Module.load (module.js:356:32)
    at Function.Module._load (module.js:312:12)
    at Function.Module.runMain (module.js:497:10)
    at startup (node.js:119:16)
    at node.js:902:3

Hence, the lesson: Raise the error event only for exceptional circumstances that must be handled.

----
Creating Your Own Event Emitters
----
Now that you are an expert at handling and raising events in Node.js, a lot of open source surface area opens up to you. A number of libraries export classes that inherit from EventEmitter and, therefore, follow the same event handling mechanism. At this stage, it is useful for you to know how you can extend EventEmitter and create a public class that has all of the functionality of EventEmitter baked in.

All you need to do to create your own EventEmitter is call the EventEmitter constructor from your class’s constructor and use the util.inherits function to set up the prototype chain. This should be second nature to you considering the amount of discussion we gave this at the start of this chapter. Listing 5-28 is a quick example to demonstrate this.

Listing 5-28. events/11custom.js
var EventEmitter = require('events').EventEmitter;
var inherits = require('util').inherits;

// Custom class
function Foo() {
    EventEmitter.call(this);
}
inherits(Foo, EventEmitter);

// Sample member function that raises an event
Foo.prototype.connect = function () {
    this.emit('connected');
}

// Usage
var foo = new Foo();
foo.on('connected', function () {
    console.log('connected raised!');
});
foo.connect();

You can see that usage of your class is exactly the same as if it was an EventEmitter. With these two simple lines, you have a fully functional custom event emitter.

----
Process Events
----
A number of classes inside core Node.js inherit from EventEmitter. The global process object is also an instance of EventEmitter, as you can see in Listing 5-29.

Listing 5-29. Sample to Demonstrate That Process Is an EventEmitter
$ node -e "console.log(process instanceof require('events').EventEmitter)"
true

Global Exception Handler
----
Any global unhandled exceptions can be intercepted by listening on the `uncaughtException` event on process. You should not resume execution outside this event handler because this only happens when your application is in an unstable state. The best strategy is to log the error for your convenience and exit the process with an error code, as shown in Listing 5-30.

Listing 5-30. process/1uncaught.js
process.on('uncaughtException', function (err) {
    console.log('Caught exception: ', err);
    console.log('Stack:', err.stack);
    process.exit(1);
});

// Intentionally cause an exception, but don't try/catch it.
nonexistentFunc();

console.log('This line will not run.');

If you run the code in Listing 5-30, you get a nice error log, as shown in Listing 5-31.

Listing 5-31. Sample Run of an Uncaught Exception
$ node 1uncaught.js
Caught exception:  [ReferenceError: nonexistentFunc is not defined]
Stack: ReferenceError: nonexistentFunc is not defined
    at Object.<anonymous> (E:\DRIVE\Google Drive\BEGINNING NODEJS\code\chapter5\
process\1uncaught.js:8:1)
    at Module._compile (module.js:456:26)
    at Object.Module._extensions..js (module.js:474:10)
    at Module.load (module.js:356:32)
    at Function.Module._load (module.js:312:12)
    at Function.Module.runMain (module.js:497:10)
    at startup (node.js:119:16)
    at node.js:902:3

The `uncaughtError` event is also raised on a process if any event emitter raises the `error` event and there are no listeners subscribed to the event emitter for this event.

Exit
----
The exit event is emitted when the process is about to exit. There is no way to abort exiting at this point. The event loop is already in teardown so you cannot do any async operations at this point. (See Listing 5-32.)

Listing 5-32. process/2exit.js
process.on('exit', function (code) {
    console.log('Exiting with code:', code);
});

process.exit(1);

Note that the event callback is passed in the exit code that the process is exiting with. This event is mostly useful for debugging and logging purposes.

Signals
----
Node.js process object also supports the UNIX concept of signals, which is a form of inter-process communication. It emulates the most important ones on Windows systems as well. A common scenario that is supported on both Windows and UNIX is when the user tries to interrupt the process using Ctrl+C key combination in the terminal. By default, Node.js will exit the process. However, if you have a listener subscribed to the `SIGINT` (signal interrupt) event, the listener is called and you can choose if you want to exit the process (process.exit) or continue execution. Listing 5-33 provides a small sample where we chose to continue running and exit after five seconds.

Listing 5-33. process/3signals.js
setTimeout(function () {
    console.log('5 seconds passed. Exiting');
}, 5000);
console.log('Started. Will exit in 5 seconds');

process.on('SIGINT', function () {
    console.log('Got SIGINT. Ignoring.');
});

If you execute this example and press Ctrl+C, you will get a message that we are choosing to ignore this. Finally, the process will exit after five seconds naturally once we don’t have any pending tasks (demonstrated in Listing 5-34).

Listing 5-34. Sample Run of Ignoring Ctrl+C Messages Demo
$ node 3signals.js
Started. Will exit in 5 seconds
Got SIGINT. Ignoring.
Got SIGINT. Ignoring.
5 seconds passed. Exiting


----
5.3 Streams
----
Streams play an important role in creating performant web applications. To understand what streams bring to the table, consider the simple case of serving a large file (1GB) from a web server. In the absence of streams, it would look like Figure 5-3. The user would have to wait a long time before they get any sign of the file they requested. This is called buffering, and we should try to limit it as much as possible. Besides the obvious bad user experience, it also wastes resources. The complete file needs to be loaded and kept in memory before we start sending it down to the user.

Figure 5-3. Buffered web response

The same scenario looks much better when we use streaming. We start reading the file and whenever we have a new chunk of data, we send it down to the client until we reach the end, as shown in Figure 5-4.

Figure 5-4. Streaming web response

This improvement in user experience and better utilization of server resources is the main motivation behind steams.

The most important concepts are that of Readable streams, Writable streams, Duplex streams, and Transform streams. A readable stream is one that you can read data from but not write to. A good example of this is process.stdin, which can be used to stream data from the standard input. A writable stream is one that you can write to but not read from. A good example is process.stdout, which can be used to stream data to the standard output. A duplex stream is one that you can both read from and write to. A good example of this is the network socket. You can write data to the network socket as well as read data from it. A transform stream is a special case of a duplex stream where the output of the stream is in some way computed from the input. These are also called through streams. A good example of these is encryption and compression streams.

All of the basic building blocks of streams are present in the Node.js core stream module that you load using require('stream'). There are base classes for implementing streams present in this module, aptly called Readable, Writable, Duplex, and Transform.

Streams in Node.js are based on events, which is why it was important to have a firm understanding of events before we could dive into streams. All of these stream classes inherit from a base abstract Stream class (abstract because you should not use it directly), which in turn inherits from EventEmitter (which we saw earlier). This hierarchy is demonstrated in Listing 5-35.

Listing 5-35. streams/1concepts/eventBased.js
var stream = require('stream');
var EventEmitter = require('events').EventEmitter;

console.log(new stream.Stream() instanceof EventEmitter); // true

console.log(new stream.Readable({}) instanceof stream.Stream); // true
console.log(new stream.Writable({}) instanceof stream.Stream); // true
console.log(new stream.Duplex({}) instanceof stream.Stream); // true
console.log(new stream.Transform({}) instanceof stream.Stream); // true

Before we look at how we can create our own streams, let’s look at how we can consume existing streams present in the Node.js library.

----
Pipe
----
All the streams support a pipe operation that can be done using the pipe member function. This is one of the things that make streams in Node.js so awesome. Consider our simple initial scenario of loading a file from the file system and streaming it to the client. This can be as simple as a code segment fileSystemStream.pipe(userSocket).

You can pipe from a stream you can read from (Readable/Duplex/Transform) to a stream you can write to (Writable/Duplex/Transform). This function is called pipe because it mimics the behavior of the command line pipe operator, for example, cat file.txt | grep lol.

The fs core module provides utility functions to create readable or writable streams from a file. Listing 5-36 is an example that streams a file from the file system to the user console.

Listing 5-36. streams/2pipe/1basic.js
var fs = require('fs');

// Create readable stream
var readableStream = fs.createReadStream('./cool.txt');

// Pipe it to stdout
readableStream.pipe(process.stdout);

You can also chain multiple streams using pipe. For example, the code in Listing 5-37 creates a read stream from a file, pipes it through a zip transform stream, and then pipes it to a writable file stream. This creates a zip file on the file system.

Listing 5-37. streams/2pipe/2chain.js
var fs = require('fs');
var gzip = require('zlib').createGzip();

var inp = fs.createReadStream('cool.txt');
var out = fs.createWriteStream('cool.txt.gz');

// Pipe chain
inp.pipe(gzip).pipe(out);

Streams in Node.js are based on events. All that the pipe operation does is subscribe to the relevant events on the source and call the relevant functions on the destination. For most purposes, pipe is all that you need to know about as an API consumer, but it is worth knowing more details when you want to delve deeper into streams.

----
Consuming Readable Streams
----
We’ve said it many times already that streams work based on events. The most important event for a readable stream is 'readable'. This event is raised whenever there is new data to be read from a stream. Once inside the event handler, you can call the read function on the stream to read data from the stream. If this is the end of the stream, the read function returns null, as demonstrated in Listing 5-38.

Listing 5-38. streams/3readable/basic.js
process.stdin.on('readable', function () {
    var buf = process.stdin.read();
    if (buf != null) {
        console.log('Got:');
        process.stdout.write(buf.toString());
    }
    else {
        console.log('Read complete!');
    }
});

A sample run of this code is shown in Listing 5-39, where we pipe data into process.stdin from the command line.

Listing 5-39. Sample Run of streams/3readable/basic.js
$ echo 'foo bar bas' | node basic.js
Got:
'foo bar bas'
Read complete!

----
Writing to Writable Streams
----
To write to a stream, you simply call write to write some data. When you have finished writing (end of stream), you simply call end. You can also write some data using the end member function if you want, as shown in Listing 5-40.

Listing 5-40. streams/4writable/basic.js
var fs = require('fs');
var ws = fs.createWriteStream('message.txt');

ws.write('foo bar ');
ws.end('bas');

In this sample, we simply wrote foo bar bas to a writable file stream.

----
Creating Your Own Stream
----
Creating your own stream is very similar to how you create your own EventEmitter. For streams you inherit from the relevant base, stream class and implement a few base methods. This is detailed in Table 5-1.

The inheritance mechanism is the same as we have seen before. That is, you call the base constructor from your class constructor and call utils.inherits after declaring you class.

Table 5-1. Creating Your Own Custom Streams

Creating a Readable Stream
----
As stated, you simply inherit from Readable class. You implement the _read member in your class, which is called by the stream API internally when someone requests data to be read. If you have data that you want to be passed on (pushed), you call the inherited member function push passing in the data. If you call push(null), this signals the end of the read stream.

Listing 5-41 is a simple example of a readable stream that returns 1-1000. If you run this, you will see all these numbers printed (as we pipe to stdout).

Listing 5-41. streams/5createReadable/counter.js
var Readable = require('stream').Readable;
var util = require('util');

function Counter() {
    Readable.call(this);
    this._max = 1000;
    this._index = 1;
}
util.inherits(Counter, Readable);

Counter.prototype._read = function () {
    var i = this._index++;
    if (i > this._max)
        this.push(null);
    else {
        var str = ' ' + i;
        this.push(str);
    }
};

// Usage, same as any other readable stream
var counter = new Counter();
counter.pipe(process.stdout);

As you can see, the underlying Readable class provides most of the stream logic for you.

Creating a Writable Stream
----
Creating your own writable stream class is similar to how we created a readable stream. You inherit from the Writable class and implement the _write method. The _write method is passed in a chunk that needs processing as its first argument.

Listing 5-42 is a simple writable stream that logs to the console all the data passed in. In this example, we simply pipe from the readable file stream to this writeable stream (Logger).

Listing 5-42. streams/6createWritable/logger.js
var Writable = require('stream').Writable;
var util = require('util');

function Logger() {
    Writable.call(this);
}
util.inherits(Logger, Writable);

Logger.prototype._write = function (chunk) {
    console.log(chunk.toString());
};

// Usage, same as any other Writable stream
var logger = new Logger();

var readStream = require('fs').createReadStream('message.txt');
readStream.pipe(logger);

Again, for most purposes, the bulk of the functionality is handled internally by the Writable base class.


----
5.4 Summary
----
Hopefully, this chapter has given you a greater appreciation of JavaScript as a language. There are a few simple ideas that provide a lot of expressive power. We started this chapter providing a crash course on JavaScript prototypal inheritance along with explaining how simple it is to do in Node.js. We then showed how Node.js comes with built-in support for common event-handling paradigms. We also demonstrated how you can create your own event emitter with simple inheritance. Finally, we looked at streams and why you would want to add them to your arsenal. You saw how easy it is to consume and write to streams in Node.js. It’s almost as if Node.js was designed for them! We ended the chapter with a discussion on how you can create your own custom streams utilizing the built-in functionality provided by Node.js core base classes.



